# -*- coding: utf-8 -*-
"""
Created on Tue Feb 24 09:12:31 2015

@author: Andre
"""

from __future__ import division

# Import scipy U(0,1) random number generator

from scipy.stats import rv_discrete

# This function is necessary for the random draw that seeds the Markov chain simulation
def DiscreteSample(xk,pk,numbOfTrial): #Adding size because it allows more 
    #flexibility to this function
    #Line below apparently necessary in order for rv_discrete to work?    
    discrete = rv_discrete(name='discrete', values=(xk,pk)) 
    sample = discrete.rvs(size=numbOfTrial)
    x = []
    x.append(sample)
    y = x[0]  
    return y

class MarkovSimDNA(object):
    
    def __init__(self, timeSteps, states, transMatrix, numbOfSim):
        self.timeSteps = timeSteps
        self.states = states
        self.transMatrix = transMatrix
        self.numbOfSim = numbOfSim
        
    def MarkovSim(timeSteps, states, transMatrix, numbOfSim):
        """
        This is a Markov chain simulation function with discrete time and states.
        The first argument (n) defines the number of steps in the simulation (and 
        thus equals the length of the list output). The second argument defines the 
        state space (in this case only two alternatives), and the third argument 
        defines the transition matrix.
        """
        chainStates = []
        #Draw a random state to initiate the chain.
        numbOfTrial=1 #I only want one output to initiate the chain
        #The middle argument in the DiscreteSample function below simply generates
        #a list of equal probabilities for all the elements in list "state"    
        currState=DiscreteSample(states,[1.0/len(states) for x in states],numbOfTrial)
        chainStates.extend(currState)
        #Now I want to simulate the chain states for the interval n-1 (everything
        #after the initial state)
        for step in range(1,timeSteps):
            probability = transMatrix[states.index(currState)] # Here I get a whole row
            #from the allProbs array associated with the current state
            currState = DiscreteSample(states,probability,1)
            chainStates.extend(currState) 
        multipleSimResults = []
        for step in range(numbOfSim):
            endState =  chainStates[numbOfSim - 1]   
            multipleSimResults.append(endState)
        print("Endstates of discrete time Markov chain simulations: " + str(multipleSimResults))
                
    def countEndStates(timeSteps, states, transMatrix, numbOfSim):
        chainStates = []
        #Draw a random state to initiate the chain.
        numbOfTrial=1 #I only want one output to initiate the chain
        #The middle argument in the DiscreteSample function below simply generates
        #a list of equal probabilities for all the elements in list "state"    
        currState=DiscreteSample(states,[1.0/len(states) for x in states],numbOfTrial)
        chainStates.extend(currState)
        #Now I want to simulate the chain states for the interval n-1 (everything
        #after the initial state)
        for step in range(1,timeSteps):
            probability = transMatrix[states.index(currState)] # Here I get a whole row
            #from the allProbs array associated with the current state
            currState = DiscreteSample(states,probability,1)
            chainStates.extend(currState) 
        multipleSimResults = []
        for step in range(numbOfSim):
            endState =  chainStates[numbOfSim - 1]   
            multipleSimResults.append(endState)
        print("The number of A endstates: " + str(multipleSimResults.count(1)))
        print("The number of C endstates: " + str(multipleSimResults.count(2)))
        print("The number of G endstates: " + str(multipleSimResults.count(3)))
        print("The number of T endstates: " + str(multipleSimResults.count(4)))
    



Sim1 = MarkovSimDNA(100, [1,2,3,4], [[0.1,0.2,0.3,0.4],[0.1,0.2,0.3,0.4],[0.1,0.2,0.3,0.4],[0.1,0.2,0.3,0.4]], 100)
print Sim1.MarkovSim()

Count1 = MarkovSimDNA(100, [1,2,3,4], [[0.1,0.2,0.3,0.4],[0.1,0.2,0.3,0.4],[0.1,0.2,0.3,0.4],[0.1,0.2,0.3,0.4]], 100)
print Count1.countEndStates()

