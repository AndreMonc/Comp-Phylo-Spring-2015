'''
Work in progress . . .
I haven't worked out all the bugs yet from this code. Current issue is:
"IndexError: index 3 is out of bounds for size 3" 
I think I'm close though!
'''

from __future__ import division
import random
from math import log 
from scipy.stats import rv_discrete

# -*- coding: utf-8 -*-
"""
Created on Tue Feb 24 14:06:39 2015

@author: Andre
"""

#Goal: to make a continuous Markov chain class containing many useful methods

'''
First I want to create the class. I use the "object" argument because this
class is not drawing on methods from any other higher class. Thus, I am 
starting with a blank slate.

The function below provides the randomly drawn nucleotide that seeds the Markov 
chain simulation
'''

class contMarkov(object): #This class will contain various methods relevant to continuous time Markov chain simulations
    #I've gone ahead and insterted some default values, so I can easily run tests on the various methods
    def __init__(self, Q=[[-1.916,0.541,0.787,0.588],[0.148,-1.069,0.415,0.506],[0.286,0.170,-0.591,0.135],[0.525,0.236,0.594,-1.355]], v=10, wTimes=[]):
        self.Q = Q #Q is my rate matrix (all rows sum to zero)
        self.v = v #v is my branch length (or total time)
        self.wTimes = wTimes  #wTimes are the waiting times between each nucleotide substitution
        
    def contMarkovSim(self): #This function will run the continuous Markov simulation
        stateSpace = (0,1,2,3) #I created the stateSpace as a tuple because I don't ever want to change it. I am always going to want to use this model on four states, corresponding to the four nucleotides in DNA (A=0,C=1,G=2,T=3)
        branchlength = 0 #Just setting my branchlength to the starting length
        i=random.choice(stateSpace) #Random draw of my seed state (or nucleotide)     
        self.wTimes = [] #Exponentially-distributed waiting times
        chainStates = [i] #i represents my seed state. Subsequent states will be appended to this list. 
        potentStates = [] #This is the list of potential states for the next substitution. The reason this list cannot simply be self.statespace is that it does not contain the current state.
        
        def DiscreteSample(xk,pk,numbOfTrial=1): #xk = events, pk = probalilities. Pulled this function from my previous code for this class. 
            #numbOfTrial = 1 because for the purposes of this assignment I will always want just a single output.            
            discrete = rv_discrete(name='discrete', values=(xk,pk)) 
            sample = discrete.rvs(size=numbOfTrial)
            x = []
            x.append(sample)
            event = x[0]  
            return event
        while branchlength < self.v:           
            probs = [] #This list will contain the three probabilities associated with transition from one nucleotide to a different nucleotide. I reset this list to 0 at the beginning of each while loop.
            ranUnif = random.uniform(0,1) #Drawing a random number between 0 and 1 so that I can find the exponentially-distributed waiting time using the equation a couple of lines down.
            lda = -(self.Q[i][i]) #defining lambda - notice that i is the first randomly seeded in Huelsenbeck, "T" was arbitrarily chosen for this purpose
            waitTime = -(1/lda)*log(ranUnif) #finding exponentially-distributed waiting time between substitutions
            self.wTimes.append(waitTime)
            branchlength = sum(wt for wt in self.wTimes) #Here I simply add the waiting time for each successive substitution to the overall branchlength
            for rate in self.Q[i]: #In this for loop I identify the non-diagonal rates (or positive rates) in the Q matrix
                if rate >=0:                
                    prob = rate/lda #and I calculate the probabilities of each
                    probs.append(prob)
            for state in stateSpace: #In this forloop I identify the possible nucleotide state and append to a list
                if state != i:
                    potentStates.append(state)
            i = DiscreteSample(potentStates, probs)
            chainStates.append(i)
            listOfStrings = [str(cs) for cs in chainStates]
            nucSubsList = [s.replace('0','A') for s in listOfStrings] #Converting numbers to the nucleotides they represent. Much easier to work with numbers for everything above. Thanks to Marco for finding this syntax!
            nucSubsList = [s.replace('1','C') for s in listOfStrings]
            nucSubsList = [s.replace('2','G') for s in listOfStrings]
            nucSubsList = [s.replace('3','T') for s in listOfStrings]
        return ("List of nucleotide substitutions: " + str(nucSubsList))
        return ("List of waiting times between substitutions: " + str(self.wTimes))
            
mkv1 = contMarkov()
print mkv1.contMarkovSim()
