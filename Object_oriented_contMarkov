from __future__ import division
import random
from math import log 
from scipy.stats import rv_discrete

# -*- coding: utf-8 -*-
"""
Created on Tue Feb 24 14:06:39 2015

@author: Andre
"""

#Goal: to make a continuous Markov chain class containing many useful methods

'''
First I want to create the class. I use the "object" argument because this
class is not drawing on methods from any other higher class. Thus, I am 
starting with a blank slate.

The function below provides the randomly drawn nucleotide that seeds the Markov 
chain simulation
'''

class contMarkov(object):
    def __init__(self, Q, v, stateSpace):
        self.Q = Q
        self.v = v
        self.stateSpace = stateSpace
 
    
    def contMarkovSim(self):
        branchlength = 0
        i=random.choice(self.stateSpace) #This is my seed state        
        exDistWXs = [] #Exponentially-distributed waiting times
        chainStates = [i] #i represents my seed state 
        probs = []
        potentStates = [] #This is the list of potential states for the next substitution. The reason this list cannot simply be self.statespace is that it does not contain the current state.
        
        def DiscreteSample(xk,pk,numbOfTrial=1): #xk = events, pk = probalilities. Pulled this function from my previous code for this class. 
            #numbOfTrial = 1 because for the purposes of this assignment I will always want just a single output.            
            discrete = rv_discrete(name='discrete', values=(xk,pk)) 
            sample = discrete.rvs(size=numbOfTrial)
            x = []
            x.append(sample)
            event = x[0]  
            return event
        while branchlength < self.v:           
            ranUnif = random.uniform(0,1)
            lda = -(self.Q[i][i]) #defining lambda - notice that i is the first randomly seeded in Huelsenbeck, "T" was arbitrarily chosen for this purpose
            waitTime = -(1/lda)*log(ranUnif)  
            exDistWXs.append(waitTime)
            branchlength = sum(wt for wt in exDistWXs)
            for rate in self.Q[i]:
                if rate >=0:                
                    prob = rate/lda 
                    probs.append(prob)
            for state in self.statespace:
                if state != i:
                    potentStates.append(state)
            i = DiscreteSample(potentStates, probs)
            chainStates.append(i)
            listOfStrings = [str(cs) for cs in chainStates]
            nucSubsList = [s.replace('0','A') for s in listOfStrings]
            nucSubsList = [s.replace('1','C') for s in listOfStrings]
            nucSubsList = [s.replace('2','G') for s in listOfStrings]
            nucSubsList = [s.replace('3','T') for s in listOfStrings]
        return ("List of nucleotide substitutions: " + str(nucSubsList))
        return ("List of waiting times between substitutions: " + str(exDistWXs))
            
mkv1 = contMarkov([[-1.916,0.541,0.787,0.588],[0.148,-1.069,0.415,0.506],[0.286,0.170,-0.591,0.135],[0.525,0.236,0.594,-1.355]],
                     5,
                     [0,1,2,3])
print mkv1.contMarkovSim()
