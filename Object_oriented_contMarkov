Work in progress . . . .


# -*- coding: utf-8 -*-
"""
Created on Tue Feb 24 14:06:39 2015

@author: Andre
"""

#Goal: to make a continuous Markov chain class containing many useful methods

'''
First I want to create the class. I use the "object" argument because this
class is not drawing on methods from any other higher class. Thus, I am 
starting with a blank slate.
'''

from __future__ import division
import random
'''
The function below provides the randomly drawn nucleotide that seeds the Markov 
chain simulation
'''

seed = random.choice(self.stateSpace)

class contMarkov(object):
    branchlength = 0
    i=random.choice(self.stateSpace) #This is my seed state
    
    def __init__(self, 
                 Q, 
                 v, 
                 stateSpace,
                 ):
        self.Q = Q
        self.v = v
        self.stateSpace = stateSpace
                        
    def contMarkovSim(self):
        list1 = [] #Exponentially-distributed waiting times
        
        while branchlength < self.v        
                        
            ranUnif = random.uniform(0,1)
            lambda = -(self.Q([i][i]))
            waitTime = -(1/lambda)*log(ranUnif)  
            list1.append(waitTime)
            branchlength = sum(wt for wt in list1)
            
        
 


   '''
    #From Jeremy
    def discSamp(events,probs):
        ranNum = sp.random.random()
        cumulProbs = []
        cumulProbs.extend([probs[0]])
        for i in range(1,len(probs)):
            cumulProbs.extend([probs[i]+cumulProbs[-1]])
        for i in range(0,len(probs)):
            if ranNum < cumulProbs[i]:
               return events[i]
        return None
    '''
        
        
        
Markov1 = contMarkov(Q = [[-1.916,0.541,0.787,0.588],[0.148,-1.069,0.415,0.506],[0.286,0.170,-0.591,0.135],[0.525,0.236,0.594,-1.355]]
                     v = 5
                     stateSpace = (0,1,2,3)
                     )
#print Markov1.contMarkSim()
