'''
Work in progress . . .

'''

from __future__ import division
import random
from math import log 
from scipy.stats import rv_discrete
import scipy as sp
import numpy as np
from scipy.stats import norm
from math import exp
import operator
import functools


# -*- coding: utf-8 -*-
"""
Created on Tue Feb 24 14:06:39 2015

@author: Andre
"""

#Goal: to make a continuous Markov chain class containing many useful methods

'''
First I want to create the class. I use the "object" argument because this
class is not drawing on methods from any other higher class. Thus, I am 
starting with a blank slate.

The function below provides the randomly drawn nucleotide that seeds the Markov 
chain simulation
'''

class contMarkov(object): #This class will contain various methods relevant to continuous time Markov chain simulations
    #I've gone ahead and insterted some default values, so I can easily run tests on the various methods
    def __init__(self, Q=[[-1.916,0.541,0.787,0.588], #Copied Q matrix from Huelsenbeck reading
                          [0.148,-1.069,0.415,0.506],
                          [0.286,0.170,-0.591,0.135],
                          [0.525,0.236,0.594,-1.355]], 
                       v=10, 
                       wTimes=[],
                       chainStates=[], 
                       stateSpace = [0,1,2,3],
                       margArray = [],
                       mpList = [],
                       allTProbs = []):
        self.Q = Q #Q is my rate matrix (all rows sum to zero)
        self.v = v #v is my branch length (or total time)
        self.wTimes = wTimes  #wTimes are the waiting times between each nucleotide substitution
        self.chainStates = chainStates
        self.stateSpace = stateSpace
        self.margArray = margArray
        self.mpList = mpList
        self.allTProbs = allTProbs
    
    def DiscreteSample(self,xk,pk,numbOfTrial=1): #xk = events, pk = probalilities. Pulled this function from my previous code for this class. 
        #numbOfTrial = 1 because for the purposes of this assignment I will always want just a single output.            
        discrete = rv_discrete(name='discrete', values=(xk,pk)) 
        sample = discrete.rvs(size=numbOfTrial)
        x = []
        x.append(sample)
        event = x[0]  
        return event  
    
    def contMarkovSim(self): #This function will run the continuous Markov simulation
        branchlength = 0 #Just setting my branchlength to the starting length
        i=random.choice(self.stateSpace) #Random draw of my seed state (or nucleotide)     
        self.wTimes = [] #Exponentially-distributed waiting times
        self.chainStates = [i] #i represents my seed state. Subsequent states will be appended to this list.      
        self.allTProbs = []
        while branchlength < self.v:           
            probs = [] #This list will contain the three probabilities associated with transition from one nucleotide to a different nucleotide. I reset this list to 0 at the beginning of each while loop.
            potentStates = [] #This is the list of potential states for the next substitution. The reason this list cannot simply be self.statespace is that it does not contain the current state.            
            
            ranUnif = random.uniform(0,1) #Drawing a random number between 0 and 1 so that I can find the exponentially-distributed waiting time using the equation a couple of lines down.
            lda = -(self.Q[i][i]) #defining lambda - notice that i is the first randomly seeded in Huelsenbeck, "T" was arbitrarily chosen for this purpose
            waitTime = -(1/lda)*log(ranUnif) #finding exponentially-distributed waiting time between substitutions
            self.wTimes.append(waitTime)
            branchlength = sum(wt for wt in self.wTimes) #Thanks Glaucia for syntax help here. I simply add the waiting time for each successive substitution to the overall branchlength
            for rate in self.Q[i]: #In this for loop I identify the non-diagonal rates (or positive rates) in the Q matrix
                if rate >=0:                
                    prob = rate/lda #and I calculate the probabilities of each
                    probs.append(prob)
                    self.allTProbs.append(prob)
            for state in self.stateSpace: #In this forloop I identify the possible nucleotide state and append to a list
                if state != i:
                    potentStates.append(state)           
            i = self.DiscreteSample(potentStates, probs)
            self.chainStates.extend(i)
            probs[:] = []
            potentStates[:] = []
        return (("List of nucleotide substitutions: " + str(self.chainStates)) + "\nList of waiting times between substitutions: " + str(self.wTimes))
    
    def conv2Letters(self):        
        letters = [str(cs) for cs in self.chainStates]
        letters = [s.replace('0','A') for s in letters] #Converting numbers to the nucleotides they represent. Much easier to work with numbers for everything above. Thanks to Marco for finding this syntax!
        letters = [l.replace('1','C') for l in letters]
        letters = [x.replace('2','G') for x in letters]
        letters = [p.replace('3','T') for p in letters]      
        return ("List of nucleotide substitutions in letters: " + str(letters))       
             
    def allMargProb(self, chainLength = 150):   
        '''
        This function will calculate the marginal probabilities of the Q rate
        matrix using a built in function "exmp"
        '''
        qArray = np.squeeze(np.asarray(self.Q))#Could not get matrix exponentiation to work, so I tried grabbing this line of code from Glaucia 
        val = sp.linalg.expm(qArray*self.v)
        self.margArray = val
        #return ("Array of marginal probabilities derived from Q matrix: ") 
        return self.margArray
        #How do I return the description for an array?
        #Finally got this to work!!!
    
    def margProbList(self): #gives a list of the four marginal probabilities (1/nucleotide transition)
        self.mpList = []        
        for i in range(0,4):
            val = d.margArray[i][i]
            self.mpList.append(val)
        return ("List of the four marginal probabilities: " + str(self.mpList))

        
    def historyProb(self):
        '''
        The goal of this function is to output the probability of the whole character history
        provided by the Markov chain simulation
        Jeremy provided the calculation pattern needed:
        P(firstNuc)*P(firstWaitingTime)*P(secNuc/firstNuc) . . . *P(1-cdf(lastWaitingTime))
        
        General strategy is to store all the relevant probabilities into a single list and then 
        multiple together all elements within that list. 
        '''
        
        # Step 1. Calculate the probability of the first nucleotide
        probList = []
        firstState = self.DiscreteSample(self.stateSpace, self.mpList)
        probList.append(self.mpList[firstState])
         
        #print ("Prob List: " + str(probList))
        
        # Step 2. Calculate probability of all waiting times up to the last waiting time
        for s in self.chainStates:        
            for wt in self.wTimes:
                wtPDFs = -self.Q[s][s]*exp(-(-self.Q[s][s])*wt) 
                probList.append(wtPDFs)
                '''
                #Above I find the probability density function for each of the 
                exponentially distributed waiting times. The equation for the 
                exponential distribution is found in the prob textbook section 
                5.5 probList.append(wtPDFs) #storing results in the probability 
                list.
                '''
        #print ("Prob List2: " + str(probList)) 
        # Step 3. Calculate the probability for all nucleotides after the first nucleotide
        probList.extend(self.allTProbs[1:]) #appending every element after the first nucleotide transition probability 
        #print ("Self Probs: " + str(self.allTProbs))
        #print ("Prob List3: " + str(probList))
               
        # Step 4. Calculate the probability of the last waiting time (1-CDF(tFinal))
        lastNuc = self.chainStates[-1]
        lastWT = self.wTimes[-1]       
        cdf = 1.0 - exp(-(self.Q[lastNuc][lastNuc]) * lastWT) # cdf = cumulative distribution function of the last waiting time
        lastWTProb = 1.0 - cdf
        probList.append(lastWTProb)
        #print ("Prob List4: " + str(probList))
    
        # Step 5. Multiply every element in the list together
        probOfCharacterHistory = functools.reduce(operator.mul, probList, 1)
        return ("The probability of the character history is: " + str(probOfCharacterHistory))
    
    
 
        


d = contMarkov()

print d.contMarkovSim()
#print d.conv2Letters()
print d.allMargProb()
print d.margProbList()
print d.wTimes
print d.chainStates
print d.historyProb()






